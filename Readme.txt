El presente trabajo tiene como finalidad, presentar una alternativa muy eficaz de guardado de información al usuario: un tda arbol binario. Hay muchas razones por la cual este es el caso; la estructura de este tda guarda información acorde a como el usuario la quiere tener organizada, y los tiempos de búsqueda de estos se ven disminuidos, como se verá más adelante. Pero antes, se explicarán los pasos para ser usado en tu programa.



Antes de usarlo en el programa, es muy importante que el usuario lea las pre y post condiciones de las funciones que se encuentran en el archivo abb.h. Una vez hecho esto, para usarlo, el usuario solo tiene poner en la cabecera de su .c #include "abb.h", descargar la biblioteca, y compilar usando la siguiente línea: "gcc -g /ruta/a/biblioteca.c /ruta/a/archivo/propio.c -Wall -Wextra -o ejecutable". Los flags -Wall y -Wextra, así como muchos otros, son meramente opcionales, pero se recomienda su uso para garantizar medianamente el correcto funcionamiento de tú código. Una vez dicho esto, usa las funciones del tda arbol como tú quieras, con la info que más te parezca, y sé la envidia de tus amigos que tienen el tda lista. 



Antes había comentado que este tda es uno de los más eficaces a la hora de guardar información, pero, ¿Por qué éste es el caso? Primero hay que recordar un poco como funciona el tda lista: el guardado de infomación es netamente lineal, significando que las listas están conectadas entre sí por un nodo que apunta a la lista siguiente. Ahí, el usuario puede insertar en cualquier posición, ya sea en la primera, última o en el medio de estas. Pero, a la hora de hacer una búsqueda, a menos que los elementos estén en las primeras dos posiciones antes mencionadas, la misma naturaleza del tda te impone que tengas que recorrer las listas una a una, hasta que se encuentre el elemento.  Ahora, reimaginemos la estructuración de los nodos, a que hay un nodo que apunta a dos hijos, cada uno de estos dos hijos apuntan a otros dos hijos, y así. Sí graficas ésto, es trivial ver por qué motivo se le conoce como tda árbol. El tema acá es que no hay criterio de ordenamiento, lo cual hace que una búsqueda se complique, ya que hay que examinar absolutamente todos los elementos para garantizar que el elemento en cuestión no se encuentra en el árbol, proceso que suena muy tedioso, ¿no? Sí descargaste ésta biblioteca para tu uso, seguro ya sabes cómo se soluciona ésto, pero seguro que te intriga saber más datos curiosos (¡Seguí leyendo!). La variante de el tda árbol, que soluciona este problema tedioso, es el muy conocido árbol binario de búsqueda (ABB para los amigos), en el cual, el guardado de elementos no es para nada arbitrario, y sigue el criterio de ordenamiento que el usuario escoja. Así, por ejemplo, sí organizas enteros, lo natural es que, al insertar un número, éste sea la raíz, y sí se inserta otro más pequeño, éste vaya a su izquierda, y sí se inserta uno más grande que ambos, éste vaya a la derecha de la raiz, y se usa éste criterio para organizar todo el árbol. Lo más interesante de esto, es que no necesariamente éste método de ordenamiento es el que te convenga más, ¡y está bien! Adáptalo a como mejor te sirva. ¡Las posibilidades son infinitas!



Una importante funcionalidad que provee ésta biblioteca, es la posibilidad de que el tda árbol almacene un puntero a una función pasada por el usuario, llamada función destructora, que pueda ser usada a la hora de guardar uno o varios elementos. Ésto es especialmente útil, cuando los elementos creados en el main del usuario se encuentran en memoria dinámica. Sí el usuario crea una función destructora que pueda liberar la memoria usada para éstos elementos, a la hora de borrarlo del árbol también se libera la memoria ocupada por el elemento, lo que significa que, una vez mandado al árbol, el usuario ya no necesita tener el puntero a ésta memoria. Imaginemos qué significaría no tener ésta funcionalidad: sí el usuario tiene un árbol con 100 elementos, cada uno teniendo memoria dinámica reservada, y éste decide que ya no necesita usarlo, y destruye el árbol, igual tendrá que liberar la memoria de todos los 100 elementos, manualmente, en el main. Qué pesadilla, ¿no?



Ahora, la parte que los aficionados a las matemáticas (y no tan) estaban esperando: ¿Cuál es la complejidad de las operaciones básicas del tda árbol? Y, para los más despistados, ésta explicación mostrará porqué un ABB es más eficaz que otros tda's, para el guardado y buscado de información. Comencemos por la más elemental: el insertar. Como se había enseñado antes, un elemento se inserta en un arbol dependiendo de la función comparador. Por lo que, se recorren de media log2(número_elementos=n) hasta llegar al final del árbol, en donde se puede insertar el elemento, en un árbol completamente arbitrario, significando una complejidad O(log2(n)). Ésto es mucho mejor que la lista, que como se explicó antes la media de complejidad es O(n) (depende de la implementación usada).Para analizar el peor caso, se usará el método de ordenamiento de antes (números menores a la izquierda y mayores a la derecha). No es dificil pensar que, sí se añaden siempre números más grandes que los ya insertados, el árbol deje de parecer un árbol y comience a parecerse más a una lista, con un nodo apuntando al siguiente elemento y así. Ésto es lo que se conoce como árbol tendiendo a lista, lo que hace que la complejidad de la función insertar, en el peor de los casos, sea O(n). Acá ya se puede observar que, en un caso promedio un ABB es muy eficaz, y que incluso en su peor caso, solo se llegue a asemejar a la complejidad de un tda lista, que no está para nada mal. Y así como se analizó la función insertar, las otras funciones tienen complejidades similares. Observese la función borrar y buscar, con complejidad media de O(log2(n)) (ya que recorre el árbol comparando el elemento en cuestión con los elementos del árbol, y sí es mayor entonces va a la rama derecha y en caso contrario a la izquierda, y así). Sí se imagina el peor caso, también sucede cuando el árbol tiende a lista, dejando dichas funciones con complejidad O(n). Por último, se tienen otras tres funciones básicas de un ABB, que se encuentran relacionadas entre sí. Una de ellas es la función recorrer árbol, en dónde se acceden a absolutamente todas las posiciones de éste, independientemente de cómo se recorra (hijo izquierdo, nodo, derecha o de otra forma), siendo la complejidad O(n) para todos los casos. Otra función parecida es la función destruir, que recorre el árbol de la manera antes descrita, y utiliza el destructor en cada uno de los elementos y libera la memoria de los nodos, siendo la complejidad O(n) también. Por último, se tiene el iterador interno del árbol, que hace exactamente lo mismo que el recorrer del árbol, la diferencia estando en que el iterador puede parar dependiendo de la función que se haya pasado como parametro. Por lo tanto, el peor caso es que el elemento en cuestión esté en la última posición del árbol (la hoja que está más a la derecha), por lo que se van a tener que acceder a todos los elementos, siendo la complejidad O(n).



Nada más qué decir, espero haber puesto en contexto el arma poderosa que tenés como biblioteca. 